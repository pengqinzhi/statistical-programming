clc
clear
clear all
% 设g=zeros(20,5,2)为保存每一次此岸商仆数可能值的矩阵，如g(i,:,:)为第i次划船前（或第i-1次后）此岸的商仆数，其中，第f(i)种可能的为存放位置为g(3,f(i),:)，商人数为g(3,f(i),1)，仆人数为g(3,f(i),2)。
% m(i)为第i次划船前满足此岸商仆数关系的所有可能情况，最大为5，初始值为0；f(i)为第i次划船前当前使用的商仆数可能值，范围为1~m(i)，初始值为1。显然m(1)=1，g(1,1,:)=[3,3]，实验最终结果g(i,f(i),:)=[0,0]。
% 初始化程序设计如下：
s=[3 3;3 2;3 1;3 0;2 2;1 1;0 3;0 2;0 1;0 0];
d=[0 1;1 0;1 1;2 0;0 2];
g=zeros(20,5,2);
m=zeros(1,20);
f=ones(1,20);
i=1;
g(i,1,:)=[3,3];
m(i)=1;
i=2;
% 搜索第i次划船前此岸商仆数的所有可能值：如果g(i-1,f(i),:)的值加上或减去（奇数次为加，偶数次为减）d中的某一值，结果为s中的某一值，则s即为第i次划船前此岸商仆数的某一可能值。其程序设计如下：
if rem(i,2)==0
    for j=1:10
        for k=1:5
            if (g(i-1,f(i-1),1)-d(k,1))==s(j,1)&&(g(i-1,f(i-1),2)-d(k,2))==s(j,2)
                m(i)=m(i)+1;
                g(i,m(i),1)=s(j,1);
                g(i,m(i),2)=s(j,2);
            end
        end
    end
else
    for j=1:10
        for k=1:5
            if (g(i-1,f(i-1),1)+d(k,1))==s(j,1)&&(g(i-1,f(i-1),2)-d(k,2))==s(j,2)
                m(i)=m(i)+1;
                g(i,m(i),1)=s(j,1);
                g(i,m(i),2)=s(j,2);
            end
        end
    end
end
% fprintf('%d %d %d\n',i,g(i,f(i),1),g(i,f(i),2))
% 去重，操作目的为判断当前取值，是否在之前状态出现，其程序设计如下：
for n=1:i-1
    if g(i,f(i),1)==g(n,f(n),1)&&g(i,f(i),2)==g(n,f(n),2)&&rem(i-n,2)==0
        if f(i)~=m(i)
            f(i)=f(i)+1;
        else
            while (f(i)==m(i))
                f(i)=1;
                m(i)=0;
                g(i,:,:)=0;
                i=i-1;
            end
            f(i)=f(i)+1;
        end
        break
    end
end
% 检查是否得到所需结果，检查当前g(i,:,:)是否为(0,0)，为了保证得到所有情况，应该在得到结果后，f(i)自增，并查重，其程序设计如下：
if g(i,f(i),1)&&g(i,f(i),2)==0
    fprintf('GO!\n')
    for n=1:i
        fprintf('%d %d %d\n',n,g(n,f(n),1),g(n,f(n),2))
    end
    f(i)=1;
    m(i)=0;
    g(i,:,:)=0;
    i=i-1;
    if f(i)~=m(i)
        f(i)=f(i)+1;
    else
        while (f(i)==m(i))
            f(i)=1;
            m(i)=0;
            g(i,:,:)=0;
            i=i-1;
        end
        f(i)=f(i)+1;
    end
end
% 所有程序设计方案与流程如下：
while i>0&&i<20
%     搜索g(i,:,:所有可能值)
%     检查当前状态之前是否出现
%     检查当前状态之前是否在出现（多次检查）
%     检查是否遍历到所需（0,0）
    i=i+1;
end

    